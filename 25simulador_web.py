# -*- coding: utf-8 -*-
"""25simulador_web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SD1AveuP9OZlYt5SaiGLBVHueXAbLaMv
"""

import streamlit as st
import random
import time

# Fun√ß√µes ajustadas para gerar contas por n√≠vel
def gerar_conta(nivel, operacao):
    """
    Gera uma pergunta de matem√°tica com base no n√≠vel e opera√ß√£o.

    Args:
        nivel (str): 'b√°sico', 'intermedi√°rio' ou 'avan√ßado'.
        operacao (str): 'Adi√ß√£o', 'Subtra√ß√£o', 'Multiplica√ß√£o' ou 'Divis√£o'.

    Returns:
        tuple: Uma tupla contendo a pergunta (str) e a resposta correta (float).
               Retorna (None, None) se a opera√ß√£o n√£o for suportada ou se houver erro na gera√ß√£o.
    """
    try:
        if operacao not in ['Multiplica√ß√£o', 'Adi√ß√£o', 'Subtra√ß√£o', 'Divis√£o']:
            return None, None

        if nivel == 'b√°sico':
            max_val = 9
        elif nivel == 'intermedi√°rio':
            max_val = 99
        elif nivel == 'avan√ßado':
            max_val = 999
        else:
            return None, None

        if operacao == 'Multiplica√ß√£o':
            num1 = random.randint(1, 99)
            num2 = random.randint(1, max_val)
            pergunta = f"{num1} x {num2}"
            resultado = float(num1 * num2)
        elif operacao == 'Adi√ß√£o':
            num1 = random.randint(1, 99)
            num2 = random.randint(1, max_val)
            pergunta = f"{num1} + {num2}"
            resultado = float(num1 + num2)
        elif operacao == 'Subtra√ß√£o':
            num2 = random.randint(1, max_val)
            num1 = random.randint(num2, 99 + max_val) # Garante resultado n√£o negativo
            pergunta = f"{num1} - {num2}"
            resultado = float(num1 - num2)
        elif operacao == 'Divis√£o':
            num2 = random.randint(1, max_val)
            resultado = random.randint(1, 99)
            num1 = num2 * resultado
            pergunta = f"{num1} √∑ {num2}"
            resultado = float(resultado)
        return pergunta, resultado

    except Exception as e:
        st.error(f"Erro ao gerar pergunta: {e}")
        return None, None

def mostrar_dicas():
    """Exibe dicas de estudo."""
    dicas = [
        "Pratique tabuada diariamente.",
        "Use jogos online para aprender matem√°tica.",
        "Resolva exerc√≠cios de diferentes n√≠veis de dificuldade.",
        "Estude com amigos e expliquem os conceitos uns aos outros.",
        "Consulte um professor se tiver d√∫vidas.",
        "Use aplicativos de matem√°tica para praticar.",
        "Tente resolver problemas de matem√°tica mentalmente.",
        "Relacione a matem√°tica com situa√ß√µes do dia a dia.",
        "N√£o tenha medo de errar, o erro faz parte do aprendizado.",
        "Mantenha uma atitude positiva em rela√ß√£o √† matem√°tica."
    ]
    st.markdown("---")
    st.subheader("Dicas de Estudo üß†")
    for dica in dicas:
        st.markdown(f"‚ú® {dica}")

# Configura√ß√£o inicial do Streamlit
st.set_page_config(page_title="Simulador de Opera√ß√µes Basicas de  M√°tematicas", page_icon="üßÆ")

# Gerenciamento de estado da sess√£o
if 'etapa' not in st.session_state:
    st.session_state.etapa = 'configura√ß√£o'
    st.session_state.respostas = []
    st.session_state.start_time = 0
    st.session_state.nome = ""
    st.session_state.nivel = ""
    st.session_state.perguntas = []
    st.session_state.respostas_corretas = []
    st.session_state.tempo_total = 0
    st.session_state.operacoes_selecionadas = ['Multiplica√ß√£o', 'Adi√ß√£o', 'Subtra√ß√£o', 'Divis√£o'] # Nomes das opera√ß√µes

# P√°gina de configura√ß√£o inicial
if st.session_state.etapa == 'configura√ß√£o':
    st.title("Simulador de Opera√ß√µes B√°sicas de Matem√°ticas üßÆ")

    nome = st.text_input("Digite seu nome:", value=st.session_state.nome).upper()
    nivel_opcoes = {
        "1 - B√°sico": "b√°sico",
        "2 - Intermedi√°rio": "intermedi√°rio",
        "3 - Avan√ßado": "avan√ßado",
    }
    nivel_selecionado_texto = st.selectbox("Escolha o n√≠vel:", list(nivel_opcoes.keys()), index=0)
    nivel = nivel_opcoes[nivel_selecionado_texto]

    # Checkbox para selecionar opera√ß√µes com nomes
    operacoes_nomes = ["Multiplica√ß√£o", "Adi√ß√£o", "Subtra√ß√£o", "Divis√£o"]
    operacoes_selecionadas = st.multiselect(
        "Selecione as opera√ß√µes:",
        operacoes_nomes,
        default=st.session_state.operacoes_selecionadas
    )
    st.session_state.operacoes_selecionadas = operacoes_selecionadas # Atualiza o estado da sess√£o

    if st.button("Iniciar Simula√ß√£o!"):
        if not nome:
            st.error("Por favor, digite seu nome.")
        elif not operacoes_selecionadas:
            st.error("Por favor, selecione pelo menos uma opera√ß√£o.")
        else:
            st.session_state.etapa = 'simula√ß√£o'
            st.session_state.nome = nome
            st.session_state.nivel = nivel
            st.session_state.perguntas = []
            st.session_state.respostas_corretas = []

            # Gerar todas as perguntas COM as opera√ß√µes selecionadas
            for op in operacoes_selecionadas:
                for _ in range(5):
                    pergunta, resposta = gerar_conta(nivel, op)
                    if pergunta:
                        st.session_state.perguntas.append(pergunta)
                        st.session_state.respostas_corretas.append(resposta)

            st.session_state.respostas = [None] * len(st.session_state.perguntas)
            st.session_state.start_time = time.time()
            st.rerun()


# P√°gina da simula√ß√£o
elif st.session_state.etapa == 'simula√ß√£o':
    st.title(f"Vamos l√°, {st.session_state.nome}! üöÄ")

    tempo_decorrido = time.time() - st.session_state.start_time
    tempo_restante = max(600 - int(tempo_decorrido), 0)
    st.progress(tempo_restante / 600)
    minutes = tempo_restante // 60
    seconds = tempo_restante % 60
    st.caption(f"Tempo restante: {minutes:02d}:{seconds:02d}")

    with st.form("respostas_form"):
        # Organizar perguntas por opera√ß√£o
        for i, pergunta in enumerate(st.session_state.perguntas):
                resposta_str = st.text_input(label=f"({i + 1}) {pergunta}", key=f"q_{i}",
                                            value=st.session_state.respostas[i] if st.session_state.respostas[i] is not None else "")
                st.session_state.respostas[i] = resposta_str  # Armazena a resposta como string

        if st.form_submit_button("Enviar Respostas"):
            # Valida√ß√£o e convers√£o das respostas para float
            respostas_float = []
            for i, resposta_str in enumerate(st.session_state.respostas):
                try:
                    resposta_float = float(
                        resposta_str.replace(",", "."))  # Converte para float, tratando v√≠rgula como decimal
                    respostas_float.append(resposta_float)
                except ValueError:
                    respostas_float.append(None)  # Se a convers√£o falhar, mant√©m como None

            st.session_state.respostas = respostas_float  # atualiza para float
            st.session_state.etapa = 'resultados'
            st.session_state.tempo_total = time.time() - st.session_state.start_time
            st.rerun()



# P√°gina de resultados
elif st.session_state.etapa == 'resultados':
    st.title("Resultados üìä")

    acertos = 0
    detalhes = []
    for i, (resposta_usuario, resposta_correta) in enumerate(zip(
            st.session_state.respostas,
            st.session_state.respostas_corretas
    )):
        if resposta_usuario is not None:
            if abs(resposta_usuario - resposta_correta) < 0.01:
                acertos += 1
                detalhes.append(f"‚úÖ ({i + 1}) {st.session_state.perguntas[i]} = {resposta_usuario:.2f}")
            else:
                detalhes.append(
                    f"‚ùå ({i + 1}) {st.session_state.perguntas[i]} = {resposta_usuario:.2f} (Correto: {resposta_correta:.2f})")
        else:
            detalhes.append(
                f"‚ùì ({i + 1}) {st.session_state.perguntas[i]} = N√£o respondido (Correto: {resposta_correta:.2f})")

    total_questoes = len(st.session_state.respostas)
    percentual_acertos = (acertos / total_questoes) * 100 if total_questoes > 0 else 0
    percentual_erros = 100 - percentual_acertos

    st.subheader("Desempenho:")
    col1, col2, col3 = st.columns(3)
    col1.metric("Acertos", f"{int(acertos)} ({percentual_acertos:.2f}%)")
    col2.metric("Erros", f"{int(total_questoes - acertos)} ({percentual_erros:.2f}%)")
    col3.metric("Tempo Total", f"{int(st.session_state.tempo_total // 60)}:{int(st.session_state.tempo_total % 60):02d}")

    st.subheader("Detalhes das Respostas:")
    for item in detalhes:
        st.markdown(item)

    if percentual_acertos <= 69:
        st.subheader("Mensagem Motivacional:")
        st.markdown(random.choice([
            "N√£o desanime! A pr√°tica leva √† perfei√ß√£o. Continue se esfor√ßando! üí™",
            "Voc√™ est√° aprendendo! Cada erro √© uma oportunidade para melhorar. üöÄ",
            "Mantenha o foco e a determina√ß√£o. Voc√™ vai chegar l√°! üî•",
            "Acredite em si mesmo! Com dedica√ß√£o, voc√™ conquista seus objetivos. üåü",
            "O importante √© n√£o desistir! Persista e voc√™ ver√° o progresso. üíØ"
        ]))
    else:
        st.subheader("Mensagem Motivacional:")
        st.markdown(random.choice([
            "Parab√©ns! Voc√™ est√° arrasando! Continue assim! üéâ",
            "Excelente desempenho! Voc√™ tem um √≥timo dom√≠nio da matem√°tica. üëç",
            "Muito bem! Seu esfor√ßo est√° trazendo resultados incr√≠veis! üèÜ",
            "Voc√™ √© um g√™nio! Continue brilhando! üåü",
            "Show de bola! Voc√™ est√° no caminho certo para o sucesso! üíØ"
        ]))

    mostrar_dicas()

    if st.button("Nova Simula√ß√£o"):
        st.session_state.clear()
        st.rerun()