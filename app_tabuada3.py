# -*- coding: utf-8 -*-
"""app_tabuada3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XgK-q9d2kjtxnXh4SyiYVnjHW3aO7t00
"""

import streamlit as st
import random
from gtts import gTTS
import os
import time

# --- Configurações Iniciais ---
TOTAL_PERGUNTAS = 10
TEMPO_RESPOSTA_SEGUNDOS = 10 # Tempo para responder cada pergunta

# --- Funções Auxiliares ---

def falar(texto):
    """Converte texto em voz e toca o áudio."""
    try:
        tts = gTTS(text=texto, lang='pt', slow=False)
        audio_file = "temp_audio.mp3"
        tts.save(audio_file)

        # Tenta tocar o áudio. Isso é o que pode falhar em alguns ambientes web.
        st.audio(audio_file, format='audio/mp3', start_time=0, loop=False)

        # Atraso para permitir que o navegador comece a reproduzir o áudio
        # Este delay é crucial para o gTTS funcionar bem no Streamlit.
        time.sleep(max(1.5, len(texto) * 0.08)) # Ajusta o sleep pelo tamanho do texto, mínimo de 1.5s

        if os.path.exists(audio_file):
            os.remove(audio_file) # Remove o arquivo temporário após tocar
    except Exception as e:
        # Aumentada a verbosidade do erro para debug, mas mantendo o warning para o usuário
        print(f"Erro detalhado ao gerar/reproduzir áudio: {e}")
        st.warning("Não foi possível reproduzir o áudio. Verifique sua conexão com a internet ou as permissões do navegador.")


def gerar_pergunta():
    """Gera uma nova pergunta de tabuada aleatória."""
    num1 = random.randint(2, 9)
    num2 = random.randint(1, 10)
    pergunta = f"Quanto é {num1} vezes {num2}?"
    resposta = num1 * num2
    return pergunta, resposta

def inicializar_estado():
    """Inicializa as variáveis de estado da sessão do Streamlit."""
    if 'iniciado' not in st.session_state:
        st.session_state.iniciado = False
    if 'perguntas_feitas' not in st.session_state:
        st.session_state.perguntas_feitas = 0
    if 'acertos' not in st.session_state:
        st.session_state.acertos = 0
    if 'erros' not in st.session_state:
        st.session_state.erros = 0
    if 'pergunta_atual' not in st.session_state:
        st.session_state.pergunta_atual = None
    if 'resposta_atual' not in st.session_state:
        st.session_state.resposta_atual = None
    if 'mostrar_resultado_pergunta' not in st.session_state:
        st.session_state.mostrar_resultado_pergunta = False
    if 'input_resposta_desabilitado' not in st.session_state:
        st.session_state.input_resposta_desabilitado = False
    if 'tempo_inicio_pergunta' not in st.session_state:
        st.session_state.tempo_inicio_pergunta = None
    # Usar st.empty() para placeholders que serão atualizados dinamicamente
    # É importante re-inicializá-los corretamente para que o Streamlit os desenhe
    if 'feedback_placeholder' not in st.session_state:
        st.session_state.feedback_placeholder = st.empty()
    if 'timer_placeholder' not in st.session_state:
        st.session_state.timer_placeholder = st.empty()
    if 'mostrar_resultados_finais' not in st.session_state:
        st.session_state.mostrar_resultados_finais = False
    # last_key para garantir que o number_input seja re-renderizado e limpo
    if 'last_key' not in st.session_state:
        st.session_state.last_key = time.time()


def proxima_pergunta():
    """Avança para a próxima pergunta ou mostra os resultados finais."""
    # Limpa placeholders antes de avançar, para evitar que o conteúdo antigo persista
    st.session_state.feedback_placeholder.empty()
    st.session_state.timer_placeholder.empty()

    st.session_state.perguntas_feitas += 1
    st.session_state.mostrar_resultado_pergunta = False
    st.session_state.input_resposta_desabilitado = False

    if st.session_state.perguntas_feitas <= TOTAL_PERGUNTAS:
        st.session_state.pergunta_atual, st.session_state.resposta_atual = gerar_pergunta()
        st.session_state.tempo_inicio_pergunta = time.time()
        falar(st.session_state.pergunta_atual)
        # Atualiza a chave para forçar um novo number_input e limpá-lo
        st.session_state.last_key = time.time()
        # Não precisa de st.rerun() aqui, o loop principal fará isso naturalmente
    else:
        st.session_state.iniciado = False
        st.session_state.mostrar_resultados_finais = True # Flag para exibir resultados finais
        # st.rerun() será chamado pelo fluxo principal após o clique no botão Próxima na última pergunta

def verificar_resposta(resposta_usuario_input):
    """Verifica a resposta do usuário e atualiza os placares."""
    # Impede que a função seja chamada múltiplas vezes para a mesma pergunta
    if st.session_state.input_resposta_desabilitado:
        return

    tempo_decorrido = time.time() - st.session_state.tempo_inicio_pergunta
    st.session_state.input_resposta_desabilitado = True # Desabilita o input e botão "Responder" IMEDIATAMENTE

    if tempo_decorrido > TEMPO_RESPOSTA_SEGUNDOS:
        st.session_state.erros += 1
        st.session_state.feedback_placeholder.error(
            f"Tempo esgotado! A resposta correta era **{st.session_state.resposta_atual}**."
        )
    # Verifica se a resposta do usuário é None (campo vazio ou não digitado)
    elif resposta_usuario_input is None:
        st.session_state.erros += 1
        st.session_state.feedback_placeholder.error(
            f"Você não digitou uma resposta. A resposta correta era **{st.session_state.resposta_atual}**."
        )
    # Converte para int apenas se não for None, para evitar erro de tipo
    elif int(resposta_usuario_input) == st.session_state.resposta_atual:
        st.session_state.acertos += 1
        st.session_state.feedback_placeholder.success("Correto!")
    else:
        st.session_state.erros += 1
        st.session_state.feedback_placeholder.error(
            f"Errado! A resposta correta era **{st.session_state.resposta_atual}**."
        )

    # Fala "Próxima" após o feedback da resposta.
    # O st.rerun() virá após a execução completa desta função no fluxo principal.
    falar("Próxima")
    st.session_state.mostrar_resultado_pergunta = True # Habilita o botão "Próxima Pergunta"


def iniciar_maratona():
    """Reinicia a maratona de perguntas."""
    st.session_state.iniciado = True
    st.session_state.perguntas_feitas = 0
    st.session_state.acertos = 0
    st.session_state.erros = 0
    st.session_state.mostrar_resultados_finais = False # Esconde resultados anteriores
    st.session_state.last_key = time.time() # Garante que o input de resposta é novo
    # Resetar placeholders para que eles possam ser recriados no loop principal
    st.session_state.feedback_placeholder = st.empty()
    st.session_state.timer_placeholder = st.empty()
    proxima_pergunta()


# --- Layout do Streamlit ---

st.set_page_config(page_title="Maratona das Tabuadas", layout="centered", initial_sidebar_state="collapsed")

st.title("Maratona das Tabuadas")

# Sempre inicializa o estado ao carregar o app
inicializar_estado()

if not st.session_state.iniciado:
    st.markdown(
        f"""
        Prepare-se para exercitar suas tabuadas de **2 a 9**!
        Você terá **{TEMPO_RESPOSTA_SEGUNDOS} segundos** para responder cada uma das **{TOTAL_PERGUNTAS} perguntas**.
        Ao final, verá seu percentual de acertos.
        """
    )
    if st.button("Iniciar Maratona", key="btn_iniciar_tela_inicial"):
        iniciar_maratona()
        st.rerun() # Força a re-execução para iniciar o jogo

    if st.session_state.mostrar_resultados_finais:
        st.markdown("---")
        st.subheader("Resultados da Última Maratona:")
        st.write(f"Acertos: **{st.session_state.acertos}**")
        st.write(f"Erros: **{st.session_state.erros}**")
        percentual = (st.session_state.acertos / TOTAL_PERGUNTAS) * 100 if TOTAL_PERGUNTAS > 0 else 0
        st.write(f"Percentual de Acertos: **{percentual:.2f}%**")

        col_res1, col_res2 = st.columns(2)
        with col_res1:
            if st.button("Reiniciar Maratona", key="btn_reiniciar_apos_finalizar"):
                iniciar_maratona()
                st.rerun() # Força a recarga para a tela inicial do jogo
        with col_res2:
            st.info("Para finalizar, basta fechar esta aba do navegador.")

    st.markdown("---")
    st.markdown("Autora: **Márcia Romanato**")

else: # Jogo em andamento
    st.header(f"Pergunta {st.session_state.perguntas_feitas} de {TOTAL_PERGUNTAS}")

    # Exibe a pergunta
    st.subheader(st.session_state.pergunta_atual)

    # Placeholder para o timer. Importante que seja recriado a cada execução se o estado mudar.
    # O timer placeholder deve ser *sempre* criado aqui para garantir que o Streamlit o encontre
    st.session_state.timer_placeholder = st.empty()
    timer_display = st.session_state.timer_placeholder # Renomear para clareza

    # Lógica do Timer (simulada)
    # O timer só deve rodar se a pergunta estiver ativa e a resposta ainda não foi processada
    if not st.session_state.mostrar_resultado_pergunta and st.session_state.tempo_inicio_pergunta:
        tempo_decorrido = time.time() - st.session_state.tempo_inicio_pergunta
        tempo_restante = max(0, TEMPO_RESPOSTA_SEGUNDOS - int(tempo_decorrido))
        timer_display.metric("Tempo Restante", f"{tempo_restante}s")

        # Se o tempo acabou e a resposta ainda não foi processada
        if tempo_restante <= 0 and not st.session_state.input_resposta_desabilitado:
            # Garante que o input e o botão sejam desabilitados
            st.session_state.input_resposta_desabilitado = True
            verificar_resposta(None) # Passa None para indicar que o tempo esgotou
            st.rerun() # Força o Streamlit a re-executar para mostrar o feedback de tempo esgotado


    # Input de resposta e botão
    col1, col2 = st.columns([0.7, 0.3])
    with col1:
        # Garante que o input seja resetado a cada nova pergunta usando uma chave única
        # O valor inicial do number_input é None.
        resposta_usuario = st.number_input(
            "Sua resposta:",
            min_value=0,
            max_value=1000, # Valor máximo razoável para tabuadas
            step=1,
            format="%d", # Garante que o input seja formatado como inteiro
            # A chave única garante que o widget seja "novo" a cada pergunta
            key=f"resposta_input_{st.session_state.perguntas_feitas}_{st.session_state.last_key}",
            disabled=st.session_state.input_resposta_desabilitado
        )
    with col2:
        st.write("") # Espaço para alinhar o botão
        # O botão "Responder" só deve ser clicável se o input não estiver desabilitado
        if st.button("Responder", disabled=st.session_state.input_resposta_desabilitado):
            # Se o campo de resposta estiver vazio, number_input retorna 0.
            # Precisamos verificar se o usuário realmente digitou algo ou se é o valor padrão.
            # Uma forma simples é considerar o valor 0 como uma resposta válida (embora improvável para tabuadas de 2 a 9)
            # ou verificar se o campo foi alterado pelo usuário.
            # Por enquanto, mantemos a lógica que se o botão foi clicado, processamos o valor atual.
            verificar_resposta(resposta_usuario)
            st.rerun() # Força o Streamlit a re-executar para mostrar o feedback

    # Feedback da pergunta (placeholder)
    # O placeholder precisa ser definido novamente em cada execução
    st.session_state.feedback_placeholder = st.empty()

    # O botão "Próxima Pergunta" só aparece após a resposta
    if st.session_state.mostrar_resultado_pergunta:
        if st.button("Próxima Pergunta", key="btn_proxima_pergunta"):
            proxima_pergunta()
            st.rerun() # Força o Streamlit a re-executar para a próxima pergunta

    st.markdown("---")
    st.write(f"Acertos: {st.session_state.acertos} | Erros: {st.session_state.erros}")
    st.markdown("Autora: **Márcia Romanato**")