# -*- coding: utf-8 -*-
"""app_tabuada6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RV73S12LjSjx3cudYwIAbfzT7E6yzmPI
"""

import streamlit as st
import random
from gtts import gTTS # Mantida para referência, mas não usada para voz neste modelo
import os
import time
import pandas as pd
import plotly.express as px

# --- Configurações Iniciais ---
TOTAL_PERGUNTAS = 30 # Ajustado para 30 perguntas
NUM_COLUMNS = 3      # Exibir as perguntas em 3 colunas

# --- Funções Auxiliares ---

def falar(texto):
    """
    Função para converter texto em voz.
    ATENÇÃO: Não está sendo usada neste modelo de 30 perguntas simultâneas,
    pois falar todas as perguntas de uma vez seria inviável para o usuário.
    Mantida no código para referência futura ou se o modo de jogo mudar.
    """
    try:
        tts = gTTS(text=texto, lang='pt', slow=False)
        audio_file = "temp_audio.mp3"
        tts.save(audio_file)
        st.audio(audio_file, format='audio/mp3', start_time=0, loop=False)
        time.sleep(max(1.5, len(texto) * 0.08)) # Pequeno atraso para reprodução
        if os.path.exists(audio_file):
            os.remove(audio_file)
    except Exception as e:
        print(f"Erro detalhado ao gerar/reproduzir áudio: {e}")
        st.warning("Não foi possível reproduzir o áudio. Verifique sua conexão com a internet ou as permissões do navegador.")


def gerar_lista_perguntas():
    """Gera uma lista de 30 perguntas de tabuada aleatórias e únicas."""
    perguntas = []
    perguntas_unicas = set() # Usado para garantir que as perguntas sejam únicas (e.g., (2,3) é diferente de (3,2))

    while len(perguntas) < TOTAL_PERGUNTAS:
        num1 = random.randint(2, 9)
        num2 = random.randint(1, 10)

        # Representa a pergunta como uma tupla (num1, num2) para verificar unicidade
        pergunta_par = (num1, num2)

        if pergunta_par not in perguntas_unicas:
            perguntas_unicas.add(pergunta_par)
            pergunta_texto = f"{num1} x {num2} = ?"
            resposta_correta = num1 * num2
            perguntas.append({'id': len(perguntas), 'pergunta': pergunta_texto, 'resposta_correta': resposta_correta})
    return perguntas

def inicializar_estado():
    """Inicializa as variáveis de estado da sessão do Streamlit."""
    if 'iniciado' not in st.session_state:
        st.session_state.iniciado = False
    if 'perguntas' not in st.session_state:
        st.session_state.perguntas = []
    # 'respostas_usuario' não é mais diretamente atribuído pelo widget,
    # mas ainda pode ser usado para inicializar o 'value' do text_input.
    if 'respostas_usuario' not in st.session_state:
        st.session_state.respostas_usuario = {}
    if 'mostrar_resultados_finais' not in st.session_state:
        st.session_state.mostrar_resultados_finais = False
    if 'acertos' not in st.session_state:
        st.session_state.acertos = 0
    if 'erros' not in st.session_state:
        st.session_state.erros = 0
    # last_key para garantir que os text_inputs sejam re-renderizados e limpos
    if 'last_key' not in st.session_state:
        st.session_state.last_key = time.time()

def iniciar_maratona():
    """Reinicia a maratona de perguntas."""
    st.session_state.iniciado = True
    st.session_state.perguntas = gerar_lista_perguntas()
    # Inicializa as respostas do usuário como None para cada pergunta no momento da geração
    st.session_state.respostas_usuario = {p['id']: None for p in st.session_state.perguntas}
    st.session_state.mostrar_resultados_finais = False
    st.session_state.acertos = 0
    st.session_state.erros = 0
    st.session_state.last_key = time.time() # Reseta a chave para limpar os inputs
    st.rerun() # Força a re-execução para iniciar o quiz

def verificar_todas_respostas():
    """Verifica todas as respostas do usuário e calcula o percentual."""
    acertos = 0
    erros = 0
    for pergunta_obj in st.session_state.perguntas:
        pergunta_id = pergunta_obj['id']
        resposta_correta = pergunta_obj['resposta_correta']

        # Constrói a chave que o st.text_input usou
        input_widget_key = f"resposta_input_{pergunta_id}_{st.session_state.last_key}"

        # Pega a resposta do usuário diretamente do st.session_state usando a chave do widget
        resposta_do_campo_str = st.session_state.get(input_widget_key, '') # Pega o valor do input, ou '' se não existir

        # Trata entradas vazias ou que consistem apenas de espaços em branco
        if not resposta_do_campo_str or not resposta_do_campo_str.strip():
            erros += 1
            continue # Pula para a próxima pergunta

        try:
            resposta_digitada = int(resposta_do_campo_str)
        except ValueError: # Captura erro se o usuário digitou algo não numérico
            erros += 1 # Entrada não numérica conta como erro
            continue # Pula para a próxima pergunta

        if resposta_digitada == resposta_correta:
            acertos += 1
        else:
            erros += 1

    st.session_state.acertos = acertos
    st.session_state.erros = erros
    st.session_state.mostrar_resultados_finais = True # Exibe os resultados
    st.session_state.iniciado = False # Volta para a tela inicial para mostrar os resultados
    st.rerun() # Força a re-execução para mostrar os resultados


# --- Layout do Streamlit ---

st.set_page_config(page_title="Maratona das Tabuadas", layout="wide", initial_sidebar_state="collapsed")

st.title("Maratona das Tabuadas")

inicializar_estado()

if not st.session_state.iniciado:
    st.markdown(
        f"""
        Prepare-se para exercitar suas tabuadas de **2 a 9**!
        Você terá **{TOTAL_PERGUNTAS} perguntas** aleatórias e únicas para resolver de uma vez.
        Ao final, poderá verificar seu percentual de acertos.
        """
    )
    if st.button("Iniciar Maratona", key="btn_iniciar_tela_inicial"):
        iniciar_maratona()

    if st.session_state.mostrar_resultados_finais:
        st.markdown("---")
        st.subheader("Resultados da Última Maratona:")
        st.write(f"Acertos: **{st.session_state.acertos}**")
        st.write(f"Erros: **{st.session_state.erros}**")

        percentual = (st.session_state.acertos / TOTAL_PERGUNTAS) * 100 if TOTAL_PERGUNTAS > 0 else 0
        st.write(f"Percentual de Acertos: **{percentual:.2f}%**")

        # --- Gráfico de Pizza (Pie Chart) ---
        data = {'Categoria': ['Acertos', 'Erros'],
                'Quantidade': [st.session_state.acertos, st.session_state.erros]}
        df = pd.DataFrame(data)

        # Plotly Express Pie Chart
        fig = px.pie(df, values='Quantidade', names='Categoria',
                     title='Desempenho Geral',
                     color_discrete_sequence=['#4CAF50', '#F44336']) # Cores verde para acertos, vermelho para erros
        fig.update_traces(textposition='inside', textinfo='percent+label') # Mostra percentual e label dentro
        st.plotly_chart(fig, use_container_width=True) # use_container_width para ajustar ao tamanho da coluna
        # --- Fim do Gráfico ---

        col_res1, col_res2 = st.columns(2)
        with col_res1:
            if st.button("Reiniciar Maratona", key="btn_reiniciar_apos_finalizar"):
                iniciar_maratona()
        with col_res2:
            st.info("Para finalizar, basta fechar esta aba do navegador.")

    st.markdown("---")
    st.markdown("Autora: **Márcia Romanato**")

else: # Jogo em andamento (mostrando as 30 perguntas)
    st.subheader("Responda todas as perguntas:")

    # Cria as colunas para exibir as perguntas
    cols = st.columns(NUM_COLUMNS)
    # perguntas_por_coluna = TOTAL_PERGUNTAS // NUM_COLUMNS # 30 / 3 = 10 perguntas por coluna

    for i, pergunta_obj in enumerate(st.session_state.perguntas):
        col_index = i % NUM_COLUMNS
        with cols[col_index]:
            st.markdown(f"**{pergunta_obj['pergunta']}**")

            # Geramos a chave única para o st.text_input
            input_widget_key = f"resposta_input_{pergunta_obj['id']}_{st.session_state.last_key}"

            # Recupera o valor atual para inicializar o input (se já existia uma resposta anterior)
            # ou string vazia se for a primeira vez.
            initial_value = st.session_state.get(input_widget_key, '')
            if initial_value is None: # Garante que None não é passado para o text_input
                initial_value = ''

            st.text_input(
                "Sua resposta:",
                key=input_widget_key, # A chave para o Streamlit armazenar o valor
                value=initial_value, # Valor inicial do campo
                type="number",       # Sugere teclado numérico
                max_chars=3          # Limita a 3 caracteres
            )
            # O valor digitado pelo usuário estará automaticamente em st.session_state[input_widget_key]
            st.markdown("---") # Separador para cada pergunta

    st.markdown("---")
    if st.button("Verificar Respostas", key="btn_verificar_respostas"):
        verificar_todas_respostas()

    st.markdown("---")
    st.markdown("Autora: **Márcia Romanato**")