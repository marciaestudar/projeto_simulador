# -*- coding: utf-8 -*-
"""app_tabuada.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13-Sy1EOl1ec6wfD77gdV7sM27Z_fMSD_
"""

import streamlit as st
import random
from gtts import gTTS
import os
import time

# --- Configurações Iniciais ---
TOTAL_PERGUNTAS = 10
TEMPO_RESPOSTA_SEGUNDOS = 10 # Tempo para responder cada pergunta

# --- Funções Auxiliares ---

def falar(texto):
    """Converte texto em voz e toca o áudio."""
    try:
        tts = gTTS(text=texto, lang='pt')
        audio_file = "temp_audio.mp3"
        tts.save(audio_file)
        st.audio(audio_file, format='audio/mp3', start_time=0)
        os.remove(audio_file) # Remove o arquivo temporário após tocar
    except Exception as e:
        st.error(f"Erro ao gerar áudio: {e}. Verifique sua conexão com a internet.")


def gerar_pergunta():
    """Gera uma nova pergunta de tabuada aleatória."""
    num1 = random.randint(2, 9)
    num2 = random.randint(1, 10)
    pergunta = f"Quanto é {num1} vezes {num2}?"
    resposta = num1 * num2
    return pergunta, resposta

def inicializar_estado():
    """Inicializa as variáveis de estado da sessão do Streamlit."""
    if 'iniciado' not in st.session_state:
        st.session_state.iniciado = False
    if 'perguntas_feitas' not in st.session_state:
        st.session_state.perguntas_feitas = 0
    if 'acertos' not in st.session_state:
        st.session_state.acertos = 0
    if 'erros' not in st.session_state:
        st.session_state.erros = 0
    if 'pergunta_atual' not in st.session_state:
        st.session_state.pergunta_atual = None
    if 'resposta_atual' not in st.session_state:
        st.session_state.resposta_atual = None
    if 'mostrar_resultado_pergunta' not in st.session_state:
        st.session_state.mostrar_resultado_pergunta = False
    if 'input_resposta_desabilitado' not in st.session_state:
        st.session_state.input_resposta_desabilitado = False
    if 'tempo_inicio_pergunta' not in st.session_state:
        st.session_state.tempo_inicio_pergunta = None
    if 'feedback_placeholder' not in st.session_state:
        st.session_state.feedback_placeholder = st.empty()
    if 'timer_placeholder' not in st.session_state:
        st.session_state.timer_placeholder = st.empty()


def proxima_pergunta():
    """Avança para a próxima pergunta ou mostra os resultados finais."""
    st.session_state.perguntas_feitas += 1
    st.session_state.mostrar_resultado_pergunta = False
    st.session_state.input_resposta_desabilitado = False
    st.session_state.feedback_placeholder.empty() # Limpa feedback anterior
    st.session_state.timer_placeholder.empty() # Limpa timer anterior

    if st.session_state.perguntas_feitas <= TOTAL_PERGUNTAS:
        st.session_state.pergunta_atual, st.session_state.resposta_atual = gerar_pergunta()
        st.session_state.tempo_inicio_pergunta = time.time()
        falar(st.session_state.pergunta_atual)
        st.session_state.feedback_placeholder.text("Qual a resposta?")
        # Re-renderiza o input de resposta para limpar
        st.session_state.last_key = time.time() # Muda a chave para forçar um novo widget
    else:
        st.session_state.iniciado = False
        st.session_state.mostrar_resultados = True

def verificar_resposta(resposta_usuario):
    """Verifica a resposta do usuário e atualiza os placares."""
    if st.session_state.input_resposta_desabilitado: # Impede múltiplas submissões
        return

    tempo_decorrido = time.time() - st.session_state.tempo_inicio_pergunta
    st.session_state.input_resposta_desabilitado = True

    if tempo_decorrido > TEMPO_RESPOSTA_SEGUNDOS:
        st.session_state.erros += 1
        st.session_state.feedback_placeholder.error(
            f"Tempo esgotado! A resposta correta era {st.session_state.resposta_atual}."
        )
    elif resposta_usuario == st.session_state.resposta_atual:
        st.session_state.acertos += 1
        st.session_state.feedback_placeholder.success("Correto!")
    else:
        st.session_state.erros += 1
        st.session_state.feedback_placeholder.error(
            f"Errado! A resposta correta era {st.session_state.resposta_atual}."
        )
    falar("Próxima") # Fala "Próxima" após a resposta

    st.session_state.mostrar_resultado_pergunta = True


def iniciar_maratona():
    """Reinicia a maratona de perguntas."""
    st.session_state.iniciado = True
    st.session_state.perguntas_feitas = 0
    st.session_state.acertos = 0
    st.session_state.erros = 0
    st.session_state.mostrar_resultados = False # Esconde resultados anteriores
    st.session_state.last_key = time.time() # Garante que o input de resposta é novo
    st.session_state.feedback_placeholder = st.empty() # Resetar placeholders
    st.session_state.timer_placeholder = st.empty() # Resetar placeholders
    proxima_pergunta()


# --- Layout do Streamlit ---

st.set_page_config(page_title="Maratona das Tabuadas", layout="centered")

st.title("Maratona das Tabuadas")

inicializar_estado()

if not st.session_state.iniciado:
    st.markdown(
        f"""
        Prepare-se para exercitar suas tabuadas de 2 a 9!
        Você terá {TEMPO_RESPOSTA_SEGUNDOS} segundos para responder cada uma das {TOTAL_PERGUNTAS} perguntas.
        Ao final, verá seu percentual de acertos.
        """
    )
    if st.button("Iniciar Maratona"):
        iniciar_maratona()
    if st.session_state.get('mostrar_resultados', False):
        st.subheader("Resultados da Última Maratona:")
        st.write(f"Acertos: {st.session_state.acertos}")
        st.write(f"Erros: {st.session_state.erros}")
        percentual = (st.session_state.acertos / TOTAL_PERGUNTAS) * 100 if TOTAL_PERGUNTAS > 0 else 0
        st.write(f"Percentual de Acertos: **{percentual:.2f}%**")
        if st.button("Reiniciar Maratona", key="reiniciar_apos_finalizar"):
            iniciar_maratona()
        if st.button("Finalizar", key="finalizar_app"):
            st.stop() # Interrompe a execução do app

else:
    st.header(f"Pergunta {st.session_state.perguntas_feitas} de {TOTAL_PERGUNTAS}")

    # Exibe a pergunta
    st.subheader(st.session_state.pergunta_atual)

    # Placeholder para o timer
    timer_display = st.session_state.timer_placeholder.empty()

    # Logica do Timer (simulada)
    if st.session_state.tempo_inicio_pergunta:
        tempo_decorrido = time.time() - st.session_state.tempo_inicio_pergunta
        tempo_restante = max(0, TEMPO_RESPOSTA_SEGUNDOS - int(tempo_decorrido))
        timer_display.metric("Tempo Restante", f"{tempo_restante}s")

        if tempo_restante == 0 and not st.session_state.input_resposta_desabilitado:
            # Se o tempo acabou e a resposta ainda não foi processada
            verificar_resposta(None) # Passa None para indicar que o tempo esgotou
            st.session_state.input_resposta_desabilitado = True # Desabilita o input
            # Força o Streamlit a re-executar para atualizar o estado
            st.experimental_rerun()


    # Input de resposta
    col1, col2 = st.columns([0.7, 0.3])
    with col1:
        resposta_usuario = st.number_input(
            "Sua resposta:",
            min_value=0,
            max_value=1000, # Valor máximo razoável para tabuadas
            step=1,
            key=f"resposta_{st.session_state.perguntas_feitas}_{st.session_state.last_key}", # Chave única para resetar
            disabled=st.session_state.input_resposta_desabilitado
        )
    with col2:
        st.write("") # Espaço para alinhar o botão
        if st.button("Responder", disabled=st.session_state.input_resposta_desabilitado):
            if resposta_usuario is not None:
                verificar_resposta(int(resposta_usuario))
                st.experimental_rerun() # Força o Streamlit a re-executar para atualizar o estado


    # Feedback da pergunta (placeholder)
    st.session_state.feedback_placeholder = st.empty() # Redefine o placeholder para o feedback

    # Botão Próxima
    if st.session_state.mostrar_resultado_pergunta:
        if st.button("Próxima Pergunta"):
            proxima_pergunta()
            st.experimental_rerun() # Força o Streamlit a re-executar para a próxima pergunta

    st.markdown("---")
    st.write(f"Acertos: {st.session_state.acertos} | Erros: {st.session_state.erros}")